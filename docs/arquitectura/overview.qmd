# Visión General del Sistema

UpTrackAI es una plataforma SaaS de monitoreo de disponibilidad diseñada para verificar el estado de APIs, sitios web y servicios en tiempo real. El sistema detecta caídas, degradaciones y comportamientos inestables, notificando a los usuarios a través de múltiples canales.

## Diagrama de Contexto (C4 Nivel 1)

El siguiente diagrama muestra cómo UpTrackAI interactúa con sus usuarios y sistemas externos.

![Diagrama de Contexto](../diagrams/img/Diagrama de Contexto C4 - UpTrackAI.png)

### Actores y Sistemas

| Actor/Sistema | Descripción | Interacción |
|--------------|-------------|-------------|
| **Usuario Final** | Desarrollador o administrador de sistemas que monitorea sus servicios | Configura targets, recibe alertas, consulta métricas |
| **Administrador** | Usuario con permisos elevados para gestión global | Acceso a todos los targets, gestión de usuarios |
| **APIs/Sitios Monitoreados** | Endpoints externos que son verificados periódicamente | Reciben requests HTTP HEAD/GET cada N segundos |
| **Telegram** | Plataforma de mensajería para notificaciones | Recibe alertas de cambio de estado |
| **PostgreSQL** | Base de datos relacional | Almacena targets, resultados, métricas y usuarios |

## Alcance Funcional

El sistema cubre el ciclo completo de monitoreo:

1. **Configuración**: El usuario registra URLs a monitorear (APIs REST, sitios web)
2. **Verificación**: El scheduler ejecuta health checks periódicos
3. **Análisis**: El sistema detecta patrones de comportamiento (estable, degradado, flapping)
4. **Notificación**: Alertas en tiempo real cuando el estado cambia
5. **Visualización**: Dashboard con métricas históricas y estadísticas

## Clean Architecture

UpTrackAI implementa Clean Architecture con separación estricta de responsabilidades:

```
┌─────────────────────────────────────────────────────────────┐
│                   CAPA DE PRESENTACIÓN                      │
│  HTTP Handlers (Gin) │ WebSocket │ CLI                      │
├─────────────────────────────────────────────────────────────┤
│                   CAPA DE APLICACIÓN                        │
│  Casos de Uso │ DTOs │ Commands/Queries                     │
├─────────────────────────────────────────────────────────────┤
│                   CAPA DE DOMINIO                           │
│  Entidades │ Value Objects │ Reglas de Negocio │ Interfaces │
├─────────────────────────────────────────────────────────────┤
│                 CAPA DE INFRAESTRUCTURA                     │
│  PostgreSQL (GORM) │ Telegram API │ JWT │ HTTP Client       │
└─────────────────────────────────────────────────────────────┘
```

**Principios aplicados:**

- **Dependency Inversion**: Las capas internas definen interfaces, las externas las implementan
- **Single Responsibility**: Cada módulo tiene una única razón de cambio
- **Open/Closed**: Extensible sin modificar código existente (nuevos senders de notificación)

## Patrones de Diseño Implementados

### Patrón Repository

Abstrae el acceso a datos permitiendo intercambiar implementaciones:

```go
// Interfaz en dominio (sin dependencias externas)
type MonitoringTargetRepository interface {
    Save(target *MonitoringTarget) (*MonitoringTarget, error)
    GetByID(id TargetId) (*MonitoringTarget, error)
    GetDueTargets() ([]*MonitoringTarget, error)
    Delete(id TargetId) error
}

// Implementación en infraestructura (conoce GORM)
type PostgresMonitoringTargetRepository struct {
    db *gorm.DB
}
```

### Patrón Worker Pool

Procesa múltiples targets concurrentemente con control de recursos:

```go
type WorkerPool struct {
    workers    int
    jobQueue   chan *MonitoringTarget
    wg         sync.WaitGroup
    processor  func(*MonitoringTarget)
}
```

### Patrón Module (Composición de Dependencias)

Cada dominio se inicializa como un módulo independiente:

```go
// Cada módulo encapsula sus capas
monitoringModule := monitoring.NewModule(db, notificationService)
securityModule := security.NewModule(db)
userModule := user.NewModule(db)
```

## Modelo de Concurrencia

El sistema utiliza goroutines y channels de Go para operaciones paralelas:

| Componente | Tipo | Descripción |
|-----------|------|-------------|
| **Worker Pool** | Goroutines | 4 workers procesando targets en paralelo |
| **Notification Dispatcher** | Channel (buffer 100) | Cola asíncrona de alertas |
| **Telegram Poller** | Goroutine | Escucha mensajes del bot en background |
| **HTTP Server** | Goroutine | Servidor web en thread separado |

## Gestión de Estados

El sistema detecta 6 estados posibles para cada target monitoreado:

| Estado | Descripción | Criterio de Detección |
|--------|-------------|----------------------|
| `UP` | Servicio saludable | 3 checks consecutivos exitosos en ≤4 intentos |
| `DOWN` | Servicio inalcanzable | 3 checks consecutivos fallidos |
| `DEGRADED` | Respuesta lenta | Latencia > umbral configurado |
| `UNSTABLE` | Fallos intermitentes | 3 iguales en 5-9 intentos |
| `FLAPPING` | Cambios rápidos | No se logran 3 iguales en 12 intentos |
| `UNKNOWN` | Sin datos suficientes | Estado inicial o error de medición |



## Variables de Entorno

El sistema se configura mediante variables de entorno:

| Variable | Descripción | Valor por Defecto |
|----------|-------------|-------------------|
| `DB_HOST` | Host de PostgreSQL | `localhost` |
| `DB_PORT` | Puerto de PostgreSQL | `5432` |
| `DB_USER` | Usuario de base de datos | `postgres` |
| `DB_PASSWORD` | Contraseña de base de datos | - |
| `DB_NAME` | Nombre de la base de datos | `uptrackai_db` |
| `PORT` | Puerto del servidor HTTP | `8080` |
| `GIN_MODE` | Modo de Gin (debug/release) | `debug` |
| `TELEGRAM_BOT_TOKEN` | Token del bot de Telegram | - |
| `TELEGRAM_BOT_NAME` | Nombre del bot | `Uptrackapp_bot` |
| `SKIP_CONNECTIVITY_CHECK` | Omitir verificación de red | `false` |
| `SECURITY_DISABLED` | Desactivar autenticación (dev) | `false` |